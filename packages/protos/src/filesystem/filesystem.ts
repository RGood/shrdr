/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.29.3
 * source: filesystem/filesystem.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export namespace filesystem {
    export class FSEntry extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2]];
        constructor(data?: any[] | ({} & (({
            file?: File;
            folder?: never;
        } | {
            file?: never;
            folder?: Folder;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("file" in data && data.file != undefined) {
                    this.file = data.file;
                }
                if ("folder" in data && data.folder != undefined) {
                    this.folder = data.folder;
                }
            }
        }
        get file() {
            return pb_1.Message.getWrapperField(this, File, 1) as File;
        }
        set file(value: File) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_file() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get folder() {
            return pb_1.Message.getWrapperField(this, Folder, 2) as Folder;
        }
        set folder(value: Folder) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_folder() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get record() {
            const cases: {
                [index: number]: "none" | "file" | "folder";
            } = {
                0: "none",
                1: "file",
                2: "folder"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
        }
        static fromObject(data: {
            file?: ReturnType<typeof File.prototype.toObject>;
            folder?: ReturnType<typeof Folder.prototype.toObject>;
        }): FSEntry {
            const message = new FSEntry({});
            if (data.file != null) {
                message.file = File.fromObject(data.file);
            }
            if (data.folder != null) {
                message.folder = Folder.fromObject(data.folder);
            }
            return message;
        }
        toObject() {
            const data: {
                file?: ReturnType<typeof File.prototype.toObject>;
                folder?: ReturnType<typeof Folder.prototype.toObject>;
            } = {};
            if (this.file != null) {
                data.file = this.file.toObject();
            }
            if (this.folder != null) {
                data.folder = this.folder.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_file)
                writer.writeMessage(1, this.file, () => this.file.serialize(writer));
            if (this.has_folder)
                writer.writeMessage(2, this.folder, () => this.folder.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FSEntry {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FSEntry();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.file, () => message.file = File.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.folder, () => message.folder = Folder.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FSEntry {
            return FSEntry.deserialize(bytes);
        }
    }
    export class File extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            size?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("size" in data && data.size != undefined) {
                    this.size = data.size;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get size() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set size(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            name?: string;
            size?: number;
        }): File {
            const message = new File({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.size != null) {
                message.size = data.size;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                size?: number;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.size != null) {
                data.size = this.size;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.size != 0)
                writer.writeInt64(2, this.size);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): File {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new File();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        message.size = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): File {
            return File.deserialize(bytes);
        }
    }
    export class Folder extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
            contents?: FSEntry[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("contents" in data && data.contents != undefined) {
                    this.contents = data.contents;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get contents() {
            return pb_1.Message.getRepeatedWrapperField(this, FSEntry, 2) as FSEntry[];
        }
        set contents(value: FSEntry[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            name?: string;
            contents?: ReturnType<typeof FSEntry.prototype.toObject>[];
        }): Folder {
            const message = new Folder({});
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.contents != null) {
                message.contents = data.contents.map(item => FSEntry.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
                contents?: ReturnType<typeof FSEntry.prototype.toObject>[];
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.contents != null) {
                data.contents = this.contents.map((item: FSEntry) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (this.contents.length)
                writer.writeRepeatedMessage(2, this.contents, (item: FSEntry) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Folder {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Folder();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.contents, () => pb_1.Message.addToRepeatedWrapperField(message, 2, FSEntry.deserialize(reader), FSEntry));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Folder {
            return Folder.deserialize(bytes);
        }
    }
    export class BroadcastManifest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            contents?: FSEntry[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("contents" in data && data.contents != undefined) {
                    this.contents = data.contents;
                }
            }
        }
        get contents() {
            return pb_1.Message.getRepeatedWrapperField(this, FSEntry, 1) as FSEntry[];
        }
        set contents(value: FSEntry[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            contents?: ReturnType<typeof FSEntry.prototype.toObject>[];
        }): BroadcastManifest {
            const message = new BroadcastManifest({});
            if (data.contents != null) {
                message.contents = data.contents.map(item => FSEntry.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                contents?: ReturnType<typeof FSEntry.prototype.toObject>[];
            } = {};
            if (this.contents != null) {
                data.contents = this.contents.map((item: FSEntry) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.contents.length)
                writer.writeRepeatedMessage(1, this.contents, (item: FSEntry) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BroadcastManifest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BroadcastManifest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.contents, () => pb_1.Message.addToRepeatedWrapperField(message, 1, FSEntry.deserialize(reader), FSEntry));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BroadcastManifest {
            return BroadcastManifest.deserialize(bytes);
        }
    }
    export class BroadcastRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            user_id?: string;
            request_id?: string;
            file_path?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("user_id" in data && data.user_id != undefined) {
                    this.user_id = data.user_id;
                }
                if ("request_id" in data && data.request_id != undefined) {
                    this.request_id = data.request_id;
                }
                if ("file_path" in data && data.file_path != undefined) {
                    this.file_path = data.file_path;
                }
            }
        }
        get user_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set user_id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get request_id() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set request_id(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get file_path() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set file_path(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            user_id?: string;
            request_id?: string;
            file_path?: string;
        }): BroadcastRequest {
            const message = new BroadcastRequest({});
            if (data.user_id != null) {
                message.user_id = data.user_id;
            }
            if (data.request_id != null) {
                message.request_id = data.request_id;
            }
            if (data.file_path != null) {
                message.file_path = data.file_path;
            }
            return message;
        }
        toObject() {
            const data: {
                user_id?: string;
                request_id?: string;
                file_path?: string;
            } = {};
            if (this.user_id != null) {
                data.user_id = this.user_id;
            }
            if (this.request_id != null) {
                data.request_id = this.request_id;
            }
            if (this.file_path != null) {
                data.file_path = this.file_path;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.user_id.length)
                writer.writeString(1, this.user_id);
            if (this.request_id.length)
                writer.writeString(2, this.request_id);
            if (this.file_path.length)
                writer.writeString(3, this.file_path);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BroadcastRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BroadcastRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.user_id = reader.readString();
                        break;
                    case 2:
                        message.request_id = reader.readString();
                        break;
                    case 3:
                        message.file_path = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BroadcastRequest {
            return BroadcastRequest.deserialize(bytes);
        }
    }
    export class DownloadRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            from_user?: string;
            file_path?: string;
            chunk_size?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("from_user" in data && data.from_user != undefined) {
                    this.from_user = data.from_user;
                }
                if ("file_path" in data && data.file_path != undefined) {
                    this.file_path = data.file_path;
                }
                if ("chunk_size" in data && data.chunk_size != undefined) {
                    this.chunk_size = data.chunk_size;
                }
            }
        }
        get from_user() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set from_user(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get file_path() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set file_path(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get chunk_size() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set chunk_size(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            from_user?: string;
            file_path?: string;
            chunk_size?: string;
        }): DownloadRequest {
            const message = new DownloadRequest({});
            if (data.from_user != null) {
                message.from_user = data.from_user;
            }
            if (data.file_path != null) {
                message.file_path = data.file_path;
            }
            if (data.chunk_size != null) {
                message.chunk_size = data.chunk_size;
            }
            return message;
        }
        toObject() {
            const data: {
                from_user?: string;
                file_path?: string;
                chunk_size?: string;
            } = {};
            if (this.from_user != null) {
                data.from_user = this.from_user;
            }
            if (this.file_path != null) {
                data.file_path = this.file_path;
            }
            if (this.chunk_size != null) {
                data.chunk_size = this.chunk_size;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.from_user.length)
                writer.writeString(1, this.from_user);
            if (this.file_path.length)
                writer.writeString(2, this.file_path);
            if (this.chunk_size.length)
                writer.writeString(3, this.chunk_size);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DownloadRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DownloadRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.from_user = reader.readString();
                        break;
                    case 2:
                        message.file_path = reader.readString();
                        break;
                    case 3:
                        message.chunk_size = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DownloadRequest {
            return DownloadRequest.deserialize(bytes);
        }
    }
    export class FileChunk extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            file_path?: string;
            content?: Uint8Array;
            chunk_count?: number;
            total_chunks?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("file_path" in data && data.file_path != undefined) {
                    this.file_path = data.file_path;
                }
                if ("content" in data && data.content != undefined) {
                    this.content = data.content;
                }
                if ("chunk_count" in data && data.chunk_count != undefined) {
                    this.chunk_count = data.chunk_count;
                }
                if ("total_chunks" in data && data.total_chunks != undefined) {
                    this.total_chunks = data.total_chunks;
                }
            }
        }
        get file_path() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set file_path(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get content() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set content(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get chunk_count() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set chunk_count(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get total_chunks() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set total_chunks(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            file_path?: string;
            content?: Uint8Array;
            chunk_count?: number;
            total_chunks?: number;
        }): FileChunk {
            const message = new FileChunk({});
            if (data.file_path != null) {
                message.file_path = data.file_path;
            }
            if (data.content != null) {
                message.content = data.content;
            }
            if (data.chunk_count != null) {
                message.chunk_count = data.chunk_count;
            }
            if (data.total_chunks != null) {
                message.total_chunks = data.total_chunks;
            }
            return message;
        }
        toObject() {
            const data: {
                file_path?: string;
                content?: Uint8Array;
                chunk_count?: number;
                total_chunks?: number;
            } = {};
            if (this.file_path != null) {
                data.file_path = this.file_path;
            }
            if (this.content != null) {
                data.content = this.content;
            }
            if (this.chunk_count != null) {
                data.chunk_count = this.chunk_count;
            }
            if (this.total_chunks != null) {
                data.total_chunks = this.total_chunks;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.file_path.length)
                writer.writeString(1, this.file_path);
            if (this.content.length)
                writer.writeBytes(2, this.content);
            if (this.chunk_count != 0)
                writer.writeInt64(3, this.chunk_count);
            if (this.total_chunks != 0)
                writer.writeInt64(4, this.total_chunks);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileChunk {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FileChunk();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.file_path = reader.readString();
                        break;
                    case 2:
                        message.content = reader.readBytes();
                        break;
                    case 3:
                        message.chunk_count = reader.readInt64();
                        break;
                    case 4:
                        message.total_chunks = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FileChunk {
            return FileChunk.deserialize(bytes);
        }
    }
    export class UploadResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            success?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
            }
        }
        get success() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            success?: boolean;
        }): UploadResponse {
            const message = new UploadResponse({});
            if (data.success != null) {
                message.success = data.success;
            }
            return message;
        }
        toObject() {
            const data: {
                success?: boolean;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success != false)
                writer.writeBool(1, this.success);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UploadResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UploadResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UploadResponse {
            return UploadResponse.deserialize(bytes);
        }
    }
    export class GetManifestRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            path?: string;
            recursive?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("path" in data && data.path != undefined) {
                    this.path = data.path;
                }
                if ("recursive" in data && data.recursive != undefined) {
                    this.recursive = data.recursive;
                }
            }
        }
        get path() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set path(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get recursive() {
            return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
        }
        set recursive(value: boolean) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            path?: string;
            recursive?: boolean;
        }): GetManifestRequest {
            const message = new GetManifestRequest({});
            if (data.path != null) {
                message.path = data.path;
            }
            if (data.recursive != null) {
                message.recursive = data.recursive;
            }
            return message;
        }
        toObject() {
            const data: {
                path?: string;
                recursive?: boolean;
            } = {};
            if (this.path != null) {
                data.path = this.path;
            }
            if (this.recursive != null) {
                data.recursive = this.recursive;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.path.length)
                writer.writeString(1, this.path);
            if (this.recursive != false)
                writer.writeBool(2, this.recursive);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetManifestRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetManifestRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.path = reader.readString();
                        break;
                    case 2:
                        message.recursive = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetManifestRequest {
            return GetManifestRequest.deserialize(bytes);
        }
    }
    export class GetManifestResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            contents?: FSEntry[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("contents" in data && data.contents != undefined) {
                    this.contents = data.contents;
                }
            }
        }
        get contents() {
            return pb_1.Message.getRepeatedWrapperField(this, FSEntry, 1) as FSEntry[];
        }
        set contents(value: FSEntry[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            contents?: ReturnType<typeof FSEntry.prototype.toObject>[];
        }): GetManifestResponse {
            const message = new GetManifestResponse({});
            if (data.contents != null) {
                message.contents = data.contents.map(item => FSEntry.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                contents?: ReturnType<typeof FSEntry.prototype.toObject>[];
            } = {};
            if (this.contents != null) {
                data.contents = this.contents.map((item: FSEntry) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.contents.length)
                writer.writeRepeatedMessage(1, this.contents, (item: FSEntry) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GetManifestResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GetManifestResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.contents, () => pb_1.Message.addToRepeatedWrapperField(message, 1, FSEntry.deserialize(reader), FSEntry));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): GetManifestResponse {
            return GetManifestResponse.deserialize(bytes);
        }
    }
    interface GrpcUnaryServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
        (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
    }
    interface GrpcStreamServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
        (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
    }
    interface GrpWritableServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (metadata: grpc_1.Metadata, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (options: grpc_1.CallOptions, callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
        (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
    }
    interface GrpcChunkServiceInterface<P, R> {
        (metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
        (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
    }
    interface GrpcPromiseServiceInterface<P, R> {
        (message: P, metadata: grpc_1.Metadata, options?: grpc_1.CallOptions): Promise<R>;
        (message: P, options?: grpc_1.CallOptions): Promise<R>;
    }
    export abstract class UnimplementedFilesystemService {
        static definition = {
            Broadcast: {
                path: "/filesystem.Filesystem/Broadcast",
                requestStream: false,
                responseStream: true,
                requestSerialize: (message: BroadcastManifest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => BroadcastManifest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: BroadcastRequest) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => BroadcastRequest.deserialize(new Uint8Array(bytes))
            },
            GetManifest: {
                path: "/filesystem.Filesystem/GetManifest",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message: GetManifestRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => GetManifestRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: GetManifestResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => GetManifestResponse.deserialize(new Uint8Array(bytes))
            },
            Download: {
                path: "/filesystem.Filesystem/Download",
                requestStream: false,
                responseStream: true,
                requestSerialize: (message: DownloadRequest) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => DownloadRequest.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: FileChunk) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => FileChunk.deserialize(new Uint8Array(bytes))
            },
            Upload: {
                path: "/filesystem.Filesystem/Upload",
                requestStream: true,
                responseStream: false,
                requestSerialize: (message: FileChunk) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes: Buffer) => FileChunk.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message: UploadResponse) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes: Buffer) => UploadResponse.deserialize(new Uint8Array(bytes))
            }
        };
        [method: string]: grpc_1.UntypedHandleCall;
        abstract Broadcast(call: grpc_1.ServerWritableStream<BroadcastManifest, BroadcastRequest>): void;
        abstract GetManifest(call: grpc_1.ServerUnaryCall<GetManifestRequest, GetManifestResponse>, callback: grpc_1.sendUnaryData<GetManifestResponse>): void;
        abstract Download(call: grpc_1.ServerWritableStream<DownloadRequest, FileChunk>): void;
        abstract Upload(call: grpc_1.ServerReadableStream<FileChunk, UploadResponse>, callback: grpc_1.sendUnaryData<UploadResponse>): void;
    }
    export class FilesystemClient extends grpc_1.makeGenericClientConstructor(UnimplementedFilesystemService.definition, "Filesystem", {}) {
        constructor(address: string, credentials: grpc_1.ChannelCredentials, options?: Partial<grpc_1.ChannelOptions>) {
            super(address, credentials, options);
        }
        Broadcast: GrpcStreamServiceInterface<BroadcastManifest, BroadcastRequest> = (message: BroadcastManifest, metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<BroadcastRequest> => {
            return super.Broadcast(message, metadata, options);
        };
        GetManifest: GrpcUnaryServiceInterface<GetManifestRequest, GetManifestResponse> = (message: GetManifestRequest, metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<GetManifestResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<GetManifestResponse>, callback?: grpc_1.requestCallback<GetManifestResponse>): grpc_1.ClientUnaryCall => {
            return super.GetManifest(message, metadata, options, callback);
        };
        Download: GrpcStreamServiceInterface<DownloadRequest, FileChunk> = (message: DownloadRequest, metadata?: grpc_1.Metadata | grpc_1.CallOptions, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<FileChunk> => {
            return super.Download(message, metadata, options);
        };
        Upload: GrpWritableServiceInterface<FileChunk, UploadResponse> = (metadata: grpc_1.Metadata | grpc_1.CallOptions | grpc_1.requestCallback<UploadResponse>, options?: grpc_1.CallOptions | grpc_1.requestCallback<UploadResponse>, callback?: grpc_1.requestCallback<UploadResponse>): grpc_1.ClientWritableStream<FileChunk> => {
            return super.Upload(metadata, options, callback);
        };
    }
}
